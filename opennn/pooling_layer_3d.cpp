//   OpenNN: Open Neural Networks Library
//   www.opennn.net
//
//   P O O L I N G   L A Y E R   3 D   C L A S S
//
//   Artificial Intelligence Techniques SL
//   artelnics@artelnics.com

#include "registry.h"
#include "tensors.h"
#include "pooling_layer_3d.h"

namespace opennn
{

Pooling3d::Pooling3d(const Shape& new_input_shape,
                     const PoolingMethod& new_pooling_method,
                     const string& new_name) : Layer()
{
    set(new_input_shape, new_pooling_method, new_name);
}


Shape Pooling3d::get_input_shape() const
{
    return input_shape;
}


Shape Pooling3d::get_output_shape() const
{
    return {input_shape[1]};
}


Pooling3d::PoolingMethod Pooling3d::get_pooling_method() const
{
    return pooling_method;
}


string Pooling3d::write_pooling_method() const
{
    return pooling_method == PoolingMethod::MaxPooling ? "MaxPooling" : "AveragePooling";
}


void Pooling3d::set(const Shape& new_input_shape, const PoolingMethod& new_pooling_method, const string& new_label)
{
    name = "Pooling3d";
    input_shape = new_input_shape;
    pooling_method = new_pooling_method;
    set_label(new_label);
}


void Pooling3d::set_pooling_method(const PoolingMethod& new_pooling_method)
{
    pooling_method = new_pooling_method;
}


void Pooling3d::set_pooling_method(const string& new_pooling_method)
{
    if (new_pooling_method == "MaxPooling") pooling_method = PoolingMethod::MaxPooling;
    else if (new_pooling_method == "AveragePooling") pooling_method = PoolingMethod::AveragePooling;
    else throw runtime_error("Unknown pooling type: " + new_pooling_method);
}


void Pooling3d::forward_propagate(const vector<TensorView>& input_views,
                                  unique_ptr<LayerForwardPropagation>& layer_forward_propagation,
                                  bool is_training)
{
    const TensorMap3 inputs = tensor_map<3>(input_views[0]);

    TensorMap2 outputs = tensor_map<2>(layer_forward_propagation->outputs);

    Pooling3dForwardPropagation* pooling_forward_propagation =
        static_cast<Pooling3dForwardPropagation*>(layer_forward_propagation.get());



    const Index batch_size = inputs.dimension(0);
    const Index sequence_length = inputs.dimension(1);
    const Index features = inputs.dimension(2);

    if (pooling_method == PoolingMethod::MaxPooling)
    {
        Tensor<Index, 2>& maximal_indices = pooling_forward_propagation->maximal_indices;

#pragma omp parallel for
        for(Index batch_index = 0; batch_index < batch_size; ++batch_index)
        {
            for(Index feature_index = 0; feature_index < features; ++feature_index)
            {
                type   max_val = -std::numeric_limits<type>::infinity();
                Index  max_idx = 0;

                for(Index seq_index = 0; seq_index < sequence_length; ++seq_index)
                {
                    const type value = inputs(batch_index, seq_index, feature_index);
                    if (value > max_val)
                    {
                        max_val = value;
                        max_idx = seq_index;
                    }
                }

                outputs(batch_index, feature_index) = max_val;
                if (is_training) maximal_indices(batch_index, feature_index) = max_idx;
            }
        }
    }
    else // AveragePooling
    {
        outputs.device(*device) =
            inputs.mean(array_1(1))
                .reshape(array_2(batch_size, features));
    }
}


void Pooling3d::back_propagate(const vector<TensorView>& input_views,
                               const vector<TensorView>& output_gradient_views,
                               unique_ptr<LayerForwardPropagation>& forward_propagation,
                               unique_ptr<LayerBackPropagation>& back_propagation) const
{
    const TensorMap3 input_tensor_map  = tensor_map<3>(input_views[0]);
    const TensorMap2 delta_tensor_map  = tensor_map<2>(output_gradient_views[0]);

    Pooling3dForwardPropagation* forward_layer  =
        static_cast<Pooling3dForwardPropagation*>(forward_propagation.get());
    Pooling3dBackPropagation* backward_layer =
        static_cast<Pooling3dBackPropagation*>(back_propagation.get());

    backward_layer->input_derivatives.setZero();

    const Index batch_size = input_tensor_map.dimension(0);
    const Index sequence_length = input_tensor_map.dimension(1);
    const Index number_of_features = input_tensor_map.dimension(2);

    if (pooling_method == PoolingMethod::MaxPooling)
    {
        for(Index batch_index = 0; batch_index < batch_size; ++batch_index)
        {
            for(Index feature_index = 0; feature_index < number_of_features; ++feature_index)
            {
                const Index maximal_index =
                    forward_layer->maximal_indices(batch_index, feature_index);

                backward_layer->input_derivatives(batch_index, maximal_index, feature_index)
                    += delta_tensor_map(batch_index, feature_index);
            }
        }
    }
    else // AveragePooling
    {
        backward_layer->input_derivatives.device(*device) +=
            delta_tensor_map.reshape(array_3(batch_size, 1, number_of_features))
                .broadcast(array_3(1, sequence_length, 1))
            / static_cast<type>(sequence_length);
    }
}


void Pooling3dForwardPropagation::initialize()
{
    const Pooling3d* pooling_layer = static_cast<Pooling3d*>(layer);

    const Index features = pooling_layer->get_output_shape()[0];
    outputs.shape = {batch_size, features};

    if (pooling_layer->get_pooling_method() == Pooling3d::PoolingMethod::MaxPooling)
        maximal_indices.resize(batch_size, features);
}


void Pooling3dBackPropagation::initialize()
{
    layer = static_cast<Pooling3d*>(layer);

    const Shape layer_input_dimensions = layer->get_input_shape();

    input_derivatives.resize(batch_size,
                             layer_input_dimensions[0],
                             layer_input_dimensions[1]);

    input_derivatives.setZero();
}


Pooling3dForwardPropagation::Pooling3dForwardPropagation(const Index new_batch_size, Layer* new_layer)
    : LayerForwardPropagation()
{
    set(new_batch_size, new_layer);
}


Pooling3dBackPropagation::Pooling3dBackPropagation(const Index new_batch_size, Layer* new_layer)
    : LayerBackPropagation()
{
    set(new_batch_size, new_layer);
}


void Pooling3d::to_XML(XMLPrinter& printer) const
{
    printer.OpenElement("Pooling3d");
    add_xml_element(printer, "InputDimensions", shape_to_string(get_input_shape()));
    add_xml_element(printer, "PoolingMethod", write_pooling_method());
    printer.CloseElement();
}

void Pooling3d::from_XML(const XMLDocument& document)
{
    const XMLElement* element = document.FirstChildElement("Pooling3d");
    if(!element) throw runtime_error("Pooling3d element is nullptr.");

    set_input_shape(string_to_shape(read_xml_string(element, "InputDimensions")));
    set_pooling_method(read_xml_string(element, "PoolingMethod"));
}


void Pooling3d::print() const
{
    cout << "Pooling3d layer" << endl
         << "Input shape: " << shape_to_string(input_shape) << endl
         << "Output shape: " << shape_to_string(get_output_shape()) << endl
         << "Pooling Method: " << write_pooling_method() << endl;
}

REGISTER(Layer, Pooling3d, "Pooling3d")
REGISTER(LayerForwardPropagation, Pooling3dForwardPropagation, "Pooling3d")
REGISTER(LayerBackPropagation, Pooling3dBackPropagation, "Pooling3d")

}

// OpenNN: Open Neural Networks Library.
// Copyright(C) 2005-2026 Artificial Intelligence Techniques, SL.
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or any later version.
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

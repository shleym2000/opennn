//   OpenNN: Open Neural Networks Library
//   www.opennn.net
//
//   I N P U T S   S E L E C T I O N   C L A S S   H E A D E R
//
//   Artificial Intelligence Techniques SL
//   artelnics@artelnics.com

#pragma once

namespace opennn
{

class TrainingStrategy;

struct TrainingResults;
struct InputsSelectionResults;

class InputsSelection
{
public:

    enum class StoppingCondition {
        MaximumTime,
        SelectionErrorGoal,
        MaximumInputs,
        MinimumInputs,
        MaximumEpochs,
        MaximumSelectionFailures
    };

    InputsSelection(const TrainingStrategy* = nullptr);
    virtual ~InputsSelection() = default;

    TrainingStrategy* get_training_strategy() const;

    bool has_training_strategy() const;

    const Index& get_trials_number() const;

    bool get_display() const;

    const type& get_validation_error_goal() const;
    const Index& get_maximum_iterations_number() const;
    const type& get_maximum_time() const;

    virtual const Index& get_minimum_inputs_number() const = 0;
    virtual const Index& get_maximum_inputs_number() const = 0;

    void set(const TrainingStrategy* = nullptr);

    void set_trials_number(const Index);

    void set_display(bool);

    void set_validation_error_goal(const type);
    void set_maximum_epochs(const Index);
    void set_maximum_time(const type);

    string write_stopping_condition(const TrainingResults&) const;

    void check() const;

    virtual InputsSelectionResults perform_input_selection() = 0;

    string get_name() const
    {
        return name;
    }

    string write_time(const type) const;

    virtual Tensor<string, 2> to_string_matrix() const { return {}; }

    virtual void from_XML(const XMLDocument&) = 0;

    virtual void to_XML(XMLPrinter&) const = 0;

    virtual void print() const {}

protected:

    TrainingStrategy* training_strategy = nullptr;

    Index trials_number = 1;

    bool display = true;
   
    // Stopping criteria

    type validation_error_goal;

    Index maximum_epochs;

    type maximum_time;

    string name;
};


struct InputsSelectionResults
{
    InputsSelectionResults(const Index = 0);

    Index get_epochs_number() const;

    void set(const Index = 0);

    string write_stopping_condition() const;

    void resize_history(const Index new_size);

    void print() const;

    // Neural network

    Tensor1 optimal_parameters;

    // Loss index

    Tensor1 training_error_history;

    Tensor1 validation_error_history;

    // Mean Validation Error of different neural networks

    Tensor1  mean_validation_error_history;

    // Mean Training Error of different neural networks

    Tensor1 mean_training_error_history;

    type optimum_training_error = numeric_limits<type>::max();

    type optimum_validation_error = numeric_limits<type>::max();

    vector<string> optimal_input_raw_variable_names;

    vector<Index> optimal_input_raw_variables_indices;

    Tensor<bool, 1> optimal_inputs;

    // Model selection

    InputsSelection::StoppingCondition stopping_condition = InputsSelection::StoppingCondition::MaximumTime;

    string elapsed_time;
};

}

// OpenNN: Open Neural Networks Library.
// Copyright(C) 2005-2026 Artificial Intelligence Techniques, SL.
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or any later version.
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
